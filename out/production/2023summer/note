// 最小堆
PriorityQueue<ListNode> minHeap = new PriorityQueue<>(Comparator.comparingInt(node -> node.val));

// 最大堆
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder())
PriorityQueue<ListNode> maxHeap = new PriorityQueue<>((node1, node2) -> node2.val - node1.val)

获取peek()   弹出poll()    加入offer()

//Deque、LinkedList同理
Deque<Integer> deque = new LinkedList();
LinkedList<Integer> deque = new LinkedList();


//获取数组/字符串长度
char[] charArray = {'H', 'e', 'l', 'l', 'o'};
int arrayLength = charArray.length;

String str = "Hello";
int strLength = str.length();


//LinkedList操作
LinkedList<Node> deque = new LinkedList<>();
deque.size()	deque.removeFirst()	deque.getFirst()	deque.add(n)


//Arrays.copy
int[] sourceArray = {1, 2, 3, 4, 5};
int[] destinationArray = Arrays.copyOf(sourceArray, sourceArray.length);	//一定有长度
int[] newArray = Arrays.copyOfRange(sourceArray, startIndex, endIndex + 1);	//左闭右开
//这样形成了新的数组，有的时候应该直接循环赋值

List<Integer> ans = new ArrayList<>();
for(int i = 0; i < counts.length; ++i){
	ans.add(counts[i]);
}
// int[]转List<Integer>


//Random
Random rand = new Random();
int r = rand.nextInt(nums.size());
// [0, nums.size() - 1]


//List
List<Integer> list = new ArrayList<>();

// 增加元素
list.add(5);
list.add(10);
list.add(15);

// 删除元素
list.remove(0); 

// 修改元素
list.set(0, 20);


List<Integer> mergedList = new ArrayList<>();
mergedList.addAll(list1);
mergedList.addAll(list2);
mergedList.addAll(list3);


//HashSet
Set<Integer> set = new HashSet<>();
        
set.add(1);
set.add(2);
set.add(3);

set.contains(elementToCheck);


// Queue
Queue<Integer> queue = new ArrayDeque<>();
queue.offer(1);
queue.peek();
queue.poll();	//移除


//左移 2的n次方
(1 << n)


// split
String str = "apple,orange,banana,grape";

// 使用逗号作为分隔符进行字符串分割，限制划分次数为 2
String[] fruits = str.split(",", 2);


// trim
String str = "   Hello, World!   ";

// 使用 trim() 方法去除开头和结尾的空白字符
String trimmedStr = str.trim();


//堆
数组模拟，索引为i
父节点(i - 1)/2	左子节点2 * i + 1